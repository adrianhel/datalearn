## 6.2.1 Знакомство с ClickHouse

[![ClickHouse](https://img.shields.io/badge/clickhouse-grey?logo=clickhouse)](https://clickhouse.com/docs/ru/)

### [Назад в Модуль 6 ⤶](/data/Module6/readme.md)

<p align="center">
<img src="/data/Module6/img/ch_logo.png" width="30%">
</p>

> ***ClickHouse*** — это колоночная аналитическая СУБД, ориентированная на выполнение сложных аналитических запросов 
> (OLAP) в режиме реального времени.  

### Ключевые преимущества
- **Колоночное хранение данных**:  
_Данные хранятся по столбцам, что значительно ускоряет выполнение агрегаций и аналитических запросов._  
- **Высокая производительность**:  
_Система способна обрабатывать миллиарды строк и десятки терабайт данных за секунды._  
- **Масштабируемость**:  
_Поддерживает горизонтальное и вертикальное масштабирование._  
- **Гибкость**:  
_Поддержка различных форматов входных/выходных данных (JSON, CSV, Parquet, Avro)._
- **Поддержка распределённых вычислений**:  
_Возможна работа в кластере для обработки петабайтных объемов данных._  
- **Простота внедрения**:  
_Легко интегрируется с BI-инструментами через стандартный SQL._
- **Open-source**:  
_Открытый исходный код, активное развитие экосистемы, может разворачиваться on-premise или в облаке._  

## 6.2.2 Установка ClickHouse
- [Руководство по установке и настройке ClickHouse](clickhouse/clickhouse_install.md)

## 6.2.3 Архитектура ClickHouse
- **Сервер ClickHouse**:  
_Основной компонент, принимающий SQL-запросы, выполняющий их обработку и возвращающий результаты. Каждый сервер может 
работать как самостоятельно, так и в составе кластера._  
- **Хранилище данных**:  
_Данные хранятся в виде частей (parts) на файловой системе сервера. Используется колоночное хранение, что обеспечивает 
эффективную работу с большими объёмами данных._  
- **Механизм репликации и шардирования**:  
_Для обеспечения отказоустойчивости и масштабируемости используется распределённое хранение данных с поддержкой реплик 
и шардинга._  
- **Механизм обработки запросов**:  
_Поддерживает исполнение сложных аналитических запросов, агрегаций, оконных функций, подзапросов и вложенных вычислений._    
- **Система фоновых процессов**:  
_Включает процессы слияния частей, сжатия, репликации и очистки данных._    

## 6.2.4 Модель хранения данных ClickHouse
Основу модели хранения данных **CH** составляет принцип раздельного хранения данных по столбцам, что 
обеспечивает эффективное сжатие и ускоряет выполнение аналитических запросов.   

**CH** сохраняет данные по столбцам, где каждый столбец таблицы хранится отдельно, что позволяет:  
- Считывать только необходимые для запроса столбцы, уменьшая объём ввода-вывода.  
- Использовать эффективные алгоритмы компрессии, поскольку значения в одном столбце часто имеют схожую природу.  
- Ускорять агрегации и аналитические операции, так как данные одного типа физически локализованы.  

#### Пример хранения

```
-- Таблица:
-- | id | name   | age |
-- |----|--------|-----|
-- | 1  | Иван   | 25  |
-- | 2  | Ольга  | 30  |

-- Физически данные будут храниться так:
-- id:   [1, 2]
-- name: ['Иван', 'Ольга']
-- age:  [25, 30]
```

## 6.2.5 Движки таблиц в ClickHouse
В **CH** используются различные [движки таблиц](clickhouse/clickhouse_engines.md), определяющие способы хранения, 
индексации и распределения данных.  
Основным и наиболее часто используемым является движок **MergeTree** и его производные.  

- **MergeTree**:  
_Обеспечивает хранение в виде упорядоченных по ключу диапазонов данных (parts), поддерживает партиционирование, 
индексацию и дедупликацию._
- **ReplacingMergeTree**, **SummingMergeTree**, **AggregatingMergeTree**:  
_Специализированные расширения MergeTree для различных задач агрегации и обновления данных._  
- **Log**, **TinyLog**, **StripeLog**:  
_Простые движки для небольших объёмов данных, без поддержки индексов и партиционирования._  
- **Distributed**:  
_Обеспечивает логическую агрегацию данных с нескольких серверов._  

#### Пример создания таблицы

```sql
CREATE TABLE example
(
    id UInt32,
    name String,
    age UInt8
)
ENGINE = MergeTree()
ORDER BY id;
```

## 6.2.6 Физическая структура хранения в ClickHouse
Данные в таблицах **MergeTree** хранятся на диске в виде отдельных частей _(parts)_.  
Каждая часть содержит набор столбцов, каждый из которых хранится в отдельном файле.  

Для каждого столбца создаются файлы:  
`.bin` — бинарные данные столбца  
`.mrk3` — файлы меток (marks), ускоряющие поиск по диапазонам  
`.txt` — иногда используется для хранения текстовых данных (например, при экспорте)  

#### Структура каталога таблицы

```
/var/lib/clickhouse/data/db_name/table_name/
  |-- 20240601_1_1_0/
      |-- id.bin
      |-- id.mrk3
      |-- name.bin
      |-- name.mrk3
      |-- age.bin
      |-- age.mrk3
      |-- primary.idx
      |-- count.txt
      |-- checksums.txt
      |-- columns.txt
```

## 6.2.7 Партиционирование и сегментация в ClickHouse
**CH** поддерживает партиционирование таблиц, позволяющее логически разбивать данные на независимые части 
_(partition)_. Это упрощает управление данными, ускоряет удаление/архивацию и повышает производительность запросов.  

Партиционирование определяется при создании таблицы с помощью выражения `PARTITION BY`.  

#### В данном примере данные будут разбиваться по месяцам посещения 

```sql
CREATE TABLE visits
(
    user_id UInt32,
    visit_date Date,
    page String
)
ENGINE = MergeTree()
PARTITION BY toYYYYMM(visit_date)
ORDER BY user_id;
```

## 6.2.8 Primary Key и индексирование в ClickHouse
**Primary Key** в **CH** не обеспечивает уникальность строк (используется для организации данных и ускорения поиска).  

**PK** определяет порядок хранения строк внутри частей и создаёт _Sparse Index_ — разреженный индекс, который указывает 
на блоки данных.  

Принцип работы _sparse index_:  

- Данные сортируются по ключу при вставке.  
- Каждые *N* строк (по умолчанию 8192) создаётся метка _(mark)_, указывающая на смещение в файле.  
- При выполнении запроса индекс позволяет быстро найти диапазон блоков, содержащих нужные значения.  

#### Пример определения PK

```sql
CREATE TABLE logs
(
    timestamp DateTime,
    user_id UInt32,
    event String
)
ENGINE = MergeTree()
ORDER BY (timestamp, user_id);
```

## 6.2.9 Сжатие данных в ClickHouse
Колоночное хранение в **CH** позволяет применять эффективные алгоритмы сжатия, такие как *LZ4*, *ZSTD*, *Deflate*.  
Алгоритм можно указывать на уровне всей системы, таблицы или даже отдельного столбца.  

Сжатие снижает требования к объёму хранения и ускоряет чтение данных, так как данные часто читаются быстрее, чем 
распаковываются.  

#### Пример метода сжатия

```sql
CREATE TABLE compression_example
(
    id UInt32 CODEC(ZSTD(3)),
    name String
)
ENGINE = MergeTree()
ORDER BY id;
```

## 6.2.10 Механизмы в ClickHouse
### Механизмы хранения метаданных  
Каждая таблица хранит вспомогательные файлы метаданных:  
- `columns.txt` — описание структуры столбцов.  
- `checksums.txt` — контрольные суммы для проверки целостности данных.  
- `primary.idx` — индекс для ускоренного поиска по _Primary Key_.  
- `count.txt` — количество строк в части.  

### Механизм слияния (Merge) и очистки (TTL)
**CH** периодически объединяет маленькие части данных в более крупные, оптимизируя хранение и производительность. 
Этот процесс осуществляется автоматически движком **MergeTree**.  

Также поддерживается механизм автоматического удаления или перемещения устаревших данных с помощью выражения **TTL** 
_(**T**ime-**T**o-**L**ive)_.  

#### Пример использования TTL

```sql
CREATE TABLE ttl_example
(
    id UInt32,
    event_time DateTime
)
ENGINE = MergeTree()
ORDER BY id
TTL event_time + INTERVAL 30 DAY;
```

### Дедупликация и агрегация на уровне хранения
Некоторые движки, такие как **ReplacingMergeTree** и **SummingMergeTree**, позволяют реализовать дедупликацию или 
агрегирование данных на этапе слияния частей. Это важно для сценариев, где обновления или агрегаты должны формироваться 
автоматически при объединении данных.  

```sql
CREATE TABLE dedup_example
(
    id UInt32,
    value String,
    version UInt32
)
ENGINE = ReplacingMergeTree(version)
ORDER BY id;
```

### Функции для управления хранением
- `OPTIMIZE TABLE` — инициирует принудительное слияние частей таблицы.  
- `ALTER TABLE ... DROP PARTITION` — удаляет партицию.  
- `ALTER TABLE ... FREEZE PARTITION` — создаёт резервную копию партиции.  

#### Пример

```sql
OPTIMIZE TABLE visits FINAL;
ALTER TABLE visits DROP PARTITION '202406';
ALTER TABLE visits FREEZE PARTITION '202406';
```