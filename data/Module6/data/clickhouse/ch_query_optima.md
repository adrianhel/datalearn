## 6.2.12 Оптимизация SQL-запросов в ClickHouse

### [Назад к ClickHouse ⤶](/data/Module6/data/clickhouse.md)

## Ключевые понятия
- **План выполнения запроса** — описание последовательности операций, выполняемых при обработке запроса.  
- **Фильтрация данных** — применение условий, ограничивающих количество обрабатываемых строк.  
- **Агрегация** — вычисление сводных значений по группам данных.  
- **Сортировка** — упорядочивание данных по одному или нескольким столбцам.  
- **Джойны (соединения)** — объединение данных из разных таблиц по определённым условиям.  
- **Партиционирование** — физическое разбиение таблицы на части по определённому ключу.  
- **Индексы** — структуры данных для ускорения выборки строк.  
- **Векторизация** — обработка данных пакетами для повышения производительности.  

## Принципы оптимизации SQL-запросов в ClickHouse
1. Минимизация объёма обрабатываемых данных.  
2. Использование возможностей колоночного хранения и архитектурных особенностей **ClickHouse**.  
3. Эффективное использование партиционирования, сортировки и индексов.  
4. Оптимизация структуры запросов: порядка операций, типов соединений, агрегаций и фильтраций.  
5. Применение специализированных функций и синтаксических конструкций **ClickHouse**.  

## Основные подходы к оптимизации
### 1. Фильтрация данных
Фильтрация должна выполняться как можно раньше. Это сокращает объём обрабатываемых данных на последующих этапах. 
В ClickHouse фильтрация реализуется через `WHERE` и `PREWHERE`.  

```sql
PREWHERE выполняет фильтрацию до декомпрессии и чтения неиспользуемых столбцов, что позволяет экономить ресурсы.
SELECT col1, col2
FROM table
PREWHERE date >= '2024-01-01'
WHERE status = 'active'
```
                  
Рекомендуется помещать в `PREWHERE` наиболее селективные (сильно ограничивающие выборку) условия по столбцам, 
входящим в сортировочный ключ.  

### 2. Использование сортировочного ключа и партиционирования
Сортировочный ключ (`ORDER BY`) и партиционирование (`PARTITION BY`) позволяют ограничить сканируемый объём данных.  

```sql
CREATE TABLE visits
(
    user_id UInt32,
    event_date Date,
    event_type String,
    ...
)
ENGINE = MergeTree
PARTITION BY toYYYYMM(event_date)
ORDER BY (user_id, event_date)
```
                  
В запросах рекомендуется использовать условия по полям, входящим в `ORDER BY` и `PARTITION BY`.  
Это позволяет **ClickHouse** быстро определять, какие партиции и диапазоны строк нужно читать.  

```sql
SELECT count(*)
FROM visits
WHERE event_date BETWEEN '2024-05-01' AND '2024-05-31'
  AND user_id = 12345
```

### 3. Использование индексов (скупых индексов)
**ClickHouse** поддерживает скупые индексы (skip indexes), которые ускоряют фильтрацию по низко-кардинальным столбцам.  

```sql
ALTER TABLE events ADD INDEX idx_type (event_type) TYPE set(100) GRANULARITY 1;
```
                  
- Скупые индексы эффективны при фильтрации по столбцам с небольшим количеством уникальных значений.  
- Не заменяют партиционирование или сортировочный ключ, но дополняют их.  

### 4. Оптимизация агрегаций
- Использование агрегационных функций **ClickHouse** (`sum`, `avg`, `uniq`, `count`).  
- Использование предварительно агрегированных таблиц или `AggregatingMergeTree`, если требуется часто делать 
повторяющиеся агрегации.  

```sql
SELECT event_date, count(*) AS cnt
FROM events
WHERE event_type = 'click'
GROUP BY event_date
ORDER BY event_date
```
                  
Для уникальных пользователей рекомендуется использовать специальные функции:  

```sql
SELECT count(DISTINCT user_id) FROM events;
SELECT uniq(user_id) FROM events;
```
                  
Функция `uniq` работает быстрее и масштабируется лучше, используя вероятностные структуры данных.  

### 5. Оптимизация джойнов (соединений)
- По возможности избегать больших `JOIN` — **ClickHouse** не оптимизирован для сложных реляционных соединений.  
- Использовать `JOIN` по ключам, входящим в сортировочный ключ.  
- Для небольших таблиц рекомендуется использовать `JOIN` с типом `Dictionary` (словарь).  

```sql
SELECT u.name, sum(e.amount)
FROM users u
INNER JOIN events e ON u.id = e.user_id
GROUP BY u.name
```
                  
Для ускорения соединений можно использовать `ANY JOIN`, если нужны только совпадающие строки:  

```sql
SELECT ...
FROM A
ANY INNER JOIN B ON A.key = B.key
```

### 6. Использование материализованных представлений
Материализованные представления позволяют автоматически агрегировать или фильтровать данные при записи, 
что ускоряет последующие запросы.  

```sql
CREATE MATERIALIZED VIEW daily_stats
ENGINE = SummingMergeTree
PARTITION BY toYYYYMM(date)
ORDER BY (date, user_id)
AS
SELECT
    date,
    user_id,
    count() AS visit_count
FROM visits
GROUP BY date, user_id
```
                  
Чтение из такого представления значительно быстрее, чем выполнение агрегации "на лету".  

### 7. Векторизация и пакетная обработка
**ClickHouse** обрабатывает данные пакетами (по блокам), что ускоряет вычисления. Не требуется ручная оптимизация, 
однако рекомендуется избегать функций, не поддерживающих векторизацию.  

### 8. Параллелизм и масштабирование
- **ClickHouse** автоматически использует все доступные ядра процессора для выполнения запросов.  
- Для горизонтального масштабирования используются шарды и реплики. Запросы к распределённым таблицам (`Distributed`) 
выполняются параллельно по всем шардам.  

```sql
CREATE TABLE distributed_events AS events
ENGINE = Distributed(cluster, db, events, rand())
```

### 9. Минимизация передачи лишних данных
- Выбирать только необходимые столбцы, избегать `SELECT *`.  
- Ограничивать количество возвращаемых строк с помощью `LIMIT`.  

```sql
SELECT id, name
FROM users
WHERE registered = 1
LIMIT 100
```

### 10. Использование специализированных функций ClickHouse
- Использование функций для работы с массивами, date/time, JSON, регулярными выражениями и др. для минимизации 
промежуточных вычислений.  
- Использование функций `arrayJoin`, `groupArray`, `groupUniqArray` для эффективной работы с массивами.  

```sql
SELECT user_id, arrayJoin(actions) AS action
FROM user_logs
WHERE has(actions, 'login')
```

## Диагностика и анализ производительности запросов
- Использование `EXPLAIN` для анализа плана выполнения запроса.  
- Использование `system.query_log` и `system.processes` для мониторинга запросов.  
- Анализ показателей `read_rows`, `read_bytes`, `result_rows` для понимания объёма обработанных данных.  

```sql
EXPLAIN SELECT count(*) FROM events WHERE event_type = 'click';
```

## Практические рекомендации
1. Использовать `PREWHERE` для селективных условий по сортировочному ключу.  
2. Избегать `SELECT *`; выбирать только необходимые столбцы.  
3. Использовать агрегированные и материализованные представления для часто повторяющихся аналитических запросов.  
4. Оптимизировать схему таблиц: выбирать правильные типы данных, партиционирование, сортировку.  
5. Минимизировать использование `JOIN` с большими таблицами.  
6. Проводить нагрузочное тестирование и анализировать планы выполнения запросов.  

## Формулы и определения
- Селективность фильтра:  
`селективность = (количество выбранных строк) / (общее количество строк)`  
- Коэффициент агрегации:  
`коэффициент агрегации = (общее количество строк) / (количество строк после GROUP BY)`  
- Суммарный объём чтения:  
`read_bytes = sum(bytes, считанных с диска по всем партициям)`  

## Примеры оптимизированных запросов

```sql
-- Использование PREWHERE и агрегации
SELECT user_id, count(*) AS cnt
FROM events
PREWHERE event_date = '2024-06-01'
WHERE event_type = 'purchase'
GROUP BY user_id
ORDER BY cnt DESC
LIMIT 10;
```

```sql
-- Фильтрация по партиционированному столбцу + агрегатная функция
SELECT toDate(event_time) AS day, uniq(user_id)
FROM logs
WHERE event_time >= '2024-05-01' AND event_time < '2024-06-01'
GROUP BY day
ORDER BY day;
```

```sql
-- Использование skip index для ускорения фильтрации
SELECT *
FROM events
WHERE low_cardinality_field = 'value'
SETTINGS force_index_by_date = 1;
```

```sql
-- Эффективное соединение с небольшой таблицей-словарём
SELECT e.event_id, d.description
FROM events e
LEFT JOIN dict_table d ON e.type = d.type_id;
```
