## 6.2.7 Сегментация и партиционирование в ClickHouse

### [Назад к ClickHouse ⤶](/data/Module6/data/clickhouse.md)

**Сегментация** и **партиционирование** — фундаментальные технологии организации хранения и обработки больших данных 
в **ClickHouse**. Их корректная настройка обеспечивает быстрое выполнение аналитических запросов, эффективное 
управление хранением, масштабируемость и отказоустойчивость системы.  

> _**Сегментация** (шардирование, sharding) — разделение данных на независимые сегменты, которые могут храниться и 
> обрабатываться на различных физических или логических узлах кластера._  

> _**Партиционирование** (partitioning) — логическое деление данных внутри одной таблицы на отдельные части (партиции), 
> обычно на основе значений одних или нескольких столбцов._

## 1. Принципы сегментации
Сегментация позволяет горизонтально масштабировать хранилище, распределяя данные по множеству серверов. 
В **ClickHouse** сегментация реализуется с помощью распределённых таблиц и механизма `Distributed`. 
Каждый сегмент _(shard)_ содержит подмножество строк таблицы.  

- **Горизонтальное масштабирование** достигается за счет добавления новых узлов с отдельными сегментами.  
- **Параллелизм обработки** — запросы могут выполняться одновременно на разных сегментах.  
- **Отказоустойчивость** — за счет репликации сегментов обеспечивается сохранность данных.  

#### Формула распределения строки по сегментам

***`shard_number = hash(key_column) % number_of_shards`***

где ***`key_column`*** — выбранный для шардирования столбец, ***`number_of_shards`*** — общее количество сегментов.  

#### Пример создания распределённой таблицы

```sql
CREATE TABLE hits_local (
    date Date,
    user_id UInt64,
    url String
) ENGINE = MergeTree()
ORDER BY (date, user_id);

CREATE TABLE hits_dist AS hits_local
ENGINE = Distributed(
    'cluster_name', 'default', 'hits_local', user_id
);
```

В данном примере строки распределяются по сегментам на основе хэш-функции от `user_id`.

## 2. Принципы партиционирования
**Партиционирование** — механизм логического деления таблицы на партиции по определённому критерию. 
В **ClickHouse** партиционирование реализуется на уровне движка **MergeTree** и его наследников.  

- **Партиция** (partition) — независимый набор данных, объединённых по ключу партиционирования.  
- **Ключ партиционирования** задаётся при создании таблицы с помощью выражения `PARTITION BY`.  
- **Внутрипартиционный порядок** обеспечивается с помощью `ORDER BY`.  

Преимущества партиционирования:  
- Быстрое удаление или архивация данных по партиции.  
- Ускорение запросов, использующих фильтрацию по полям партиционирования.  
- Снижение объема обрабатываемых данных за счет **pruning** (отсечения неактуальных партиций на этапе выполнения запроса).  

#### Пример создания таблицы с партиционированием

```sql
CREATE TABLE events (
    event_date Date,
    event_type String,
    user_id UInt64
) ENGINE = MergeTree()
PARTITION BY toYYYYMM(event_date)
ORDER BY (event_type, user_id);
```

В данном примере данные группыруются в партиции по месяцу события `toYYYYMM(event_date)`.  

Удаление партиции возможно одной командой:  

```sql
ALTER TABLE events DROP PARTITION 202405;
```

## 3. Стратегии и подходы к партиционированию
Эффективность партиционирования зависит от выбора ключа партиционирования:   
- **По времени**: чаще всего используется для событийных данных, логов, метрик. Наиболее популярные функции для ключей 
партиционирования — `toYYYYMM`, `toYYYYMMDD`.  
- **По идентификаторам**: например, `user_id` или `region_id`, если данные сильно сегментированы.  
- **Составные ключи**: комбинация нескольких полей, например, (`region_id`, `toYYYYMM(date)`).  

Выбор слишком мелкой партиции (например, по дню для маленького объёма данных) приведёт к росту числа файлов 
и ухудшению производительности. Слишком крупная партиция (например, за год) снижает выгоду от партиционирования.  

## 4. Практическое применение партиционирования
- **Удаление неактуальных данных**:

```sql
ALTER TABLE events DROP PARTITION 202404;
```
        
- **Перемещение партиций между серверами**:

```sql
ALTER TABLE events FREEZE PARTITION 202404;
-- Копирование файлов партиции на другой сервер и восстановление:
ALTER TABLE events ATTACH PARTITION 202404;
```

- **Архивация данных**: партиции можно экспортировать для долгосрочного хранения.

## 5. Партиционирование и порядок хранения
В движке **MergeTree** физическое хранение данных организовано в виде частей _(parts)_, каждая из которых 
относится к определённой партиции. Внутри части строки упорядочены по `ORDER BY`, что ускоряет выполнение 
диапазонных и аналитических запросов.  

#### Структура хранения
- **Партиция** — отдельная директория на диске, содержащая данные и индексы по конкретному значению ключа 
партиционирования.  
- **Части** — файлы внутри партиции, возникающие в процессе вставки и объединения данных.  

## 6. Механизм отсечения партиций (partition pruning)
При выполнении запроса **ClickHouse** автоматически определяет, какие партиции могут содержать нужные данные 
на основании условий фильтрации в `WHERE`. Это позволяет читать только необходимые файлы, значительно ускоряя обработку.  

```sql
SELECT count(*)
FROM events
WHERE event_date BETWEEN '2024-05-01' AND '2024-05-31'
```

В данном примере будут обработаны только партиции за май 2024 года.  

## 7. Взаимосвязь партиционирования и сегментации
В распределённых кластерах **ClickHouse** партиционирование применяется внутри каждого сегмента. Сегментация определяет, 
на каких физических узлах хранятся данные, а партиционирование — как данные организованы внутри каждой таблицы.  

- **`Шард → Партиция → Часть`**: сегмент содержит множество партиций, каждая партиция состоит из частей.  

## 8. Примеры сложных конфигураций
#### Составное партиционирование и порядок

```sql
CREATE TABLE sales (
    sale_date Date,
    region_id UInt32,
    product_id UInt32,
    revenue Float64
) ENGINE = MergeTree()
PARTITION BY (region_id, toYYYYMM(sale_date))
ORDER BY (sale_date, product_id);
```

Такая конфигурация позволяет эффективно фильтровать и удалять данные не только по дате, но и по региону.

#### Код для репликации и распределения

```sql
CREATE TABLE logs_local (
    log_date Date,
    level String,
    message String
) ENGINE = ReplicatedMergeTree('/clickhouse/tables/{shard}/logs_local', '{replica}')
PARTITION BY toYYYYMMDD(log_date)
ORDER BY (level, log_date);

CREATE TABLE logs_dist AS logs_local
ENGINE = Distributed('logs_cluster', 'default', 'logs_local', rand());
```

В данном примере используется партиционирование по дню и репликация внутри сегментов.

## 9. Особенности, ограничения и рекомендации
- После создания таблицы изменить ключ партиционирования невозможно; требуется создание новой таблицы и перенос данных.  
- Не стоит делать партиции слишком мелкими (например, по часу или по уникальным идентификаторам) — это приводит 
к фрагментации и увеличению нагрузки на файловую систему.  
- Следует учитывать типичные запросы при выборе ключа партиционирования: если часто фильтруются данные по определённому 
полю, его целесообразно включить в ключ.  
- Для больших объёмов данных рекомендуется использовать партиционирование по времени с разумным периодом 
(например, месяц или неделя).  
- В кластере важно согласованно настраивать партиционирование на всех сегментах.  