## 7.12.1 Spark GraphX: обработка графов

### [Назад в Модуль 7 ⤶](/data/Module7/readme.md)

- **Граф** — математическая структура, состоящая из вершин (vertices) и рёбер (edges), которые соединяют пары вершин.  

- **Ориентированный граф (digraph)** — граф, в котором рёбра имеют направление.  

- **Неориентированный граф** — граф, в котором рёбра не имеют направления.  

- **Атрибуты** — дополнительная информация, связанная с вершинами или рёбрами (например, веса, метки и т.д.).  

## 7.12.2 Архитектура GraphX
GraphX реализует граф как комбинацию двух RDD:  
- **Vertex RDD** — RDD пар `(VertexId, VertexAttr)`, где `VertexId` — уникальный идентификатор вершины, `VertexAttr` — 
атрибут вершины.  
- **Edge RDD** — RDD объектов Edge с полями `srcId`, `dstId` и `attr`, представляющими идентификаторы начальной и конечной 
вершин и атрибут ребра соответственно.  

Граф в GraphX представлен объектом класса `Graph[VD, ED]`, где `VD` — тип атрибутов вершин, `ED` — тип атрибутов рёбер.  

## 7.12.3 Создание графа

```scala
import org.apache.spark.graphx._
import org.apache.spark.rdd.RDD

// Пример данных
val vertexArray = Array(
  (1L, "Alice"),
  (2L, "Bob"),
  (3L, "Charlie"),
  (4L, "David")
)

val edgeArray = Array(
  Edge(1L, 2L, "friend"),
  Edge(2L, 3L, "follow"),
  Edge(3L, 4L, "friend"),
  Edge(4L, 1L, "follow")
)

// Создание RDD
val vertexRDD: RDD[(Long, String)] = sc.parallelize(vertexArray)
val edgeRDD: RDD[Edge[String]] = sc.parallelize(edgeArray)

// Создание графа
val graph: Graph[String, String] = Graph(vertexRDD, edgeRDD)
```

## 7.12.4 Основные операции над графами
### Трансформации
- **mapVertices:** применяет функцию к каждому атрибуту вершины.  
- **mapEdges:** применяет функцию к каждому атрибуту ребра.  
- **subgraph:** строит подграф на основе предикатов для вершин и/или рёбер.  
- **reverse:** возвращает граф с обращённым направлением рёбер.  
- **joinVertices:** объединяет дополнительные данные с вершинами графа по их идентификатору.  

```scala
// Пример: добавим метку к имени пользователя
val newGraph = graph.mapVertices{ case (id, name) => s"User: $name" }
```
                  
### Действия (Actions)
- **vertices:** возвращает RDD всех вершин.  
- **edges:** возвращает RDD всех рёбер.  
- **triplets:** возвращает RDD объектов `EdgeTriplet`, объединяющих атрибуты начальной и конечной вершин с атрибутом ребра.  

```scala
// Пример: выводим все тройки (вершина-ребро-вершина)
graph.triplets.collect.foreach { triplet =>
  println(s"${triplet.srcAttr} --${triplet.attr}--> ${triplet.dstAttr}")
}
```

## 7.12.5 Графовые алгоритмы в GraphX
- **PageRank:** вычисление рейтинга важности вершин на основе структуры графа.  
- **Connected Components:** определение связных компонент неориентированного графа.  
- **Strongly Connected Components:** определение сильно связных компонент в ориентированных графах.  
- **Triangle Count:** подсчёт числа треугольников, в которых участвует каждая вершина.  
- **Shortest Paths:** нахождение кратчайших путей между вершинами.  
- **Label Propagation:** алгоритм кластеризации для обнаружения сообществ.  

```scala
// Пример: запуск PageRank
val ranks = graph.pageRank(0.0001).vertices
ranks.collect.foreach { case (id, rank) => println(s"Vertex $id has rank $rank") }

// Пример: связные компоненты
val cc = graph.connectedComponents().vertices

// Пример: подсчёт треугольников
val triangleCounts = graph.triangleCount().vertices
```

## 7.12.6 Pregel API
GraphX поддерживает модель вычислений **Pregel** для гибкой реализации итеративных алгоритмов на графах. 
  
Основные компоненты Pregel:
- **vertex program:** функция обновления атрибута вершины на основе полученного сообщения.  
- **send message:** функция генерации сообщений для соседей по рёбрам.  
- **message combiner:** функция агрегации сообщений, полученных вершиной.  
   
Вызов `pregel` выглядит следующим образом:   

```scala
val initialMsg = 0

def vprog(id: VertexId, attr: Int, msg: Int): Int = math.max(attr, msg)

def sendMsg(triplet: EdgeTriplet[Int, Int]): Iterator[(VertexId, Int)] = {
  Iterator((triplet.dstId, triplet.srcAttr + 1))
}

def mergeMsg(a: Int, b: Int): Int = math.max(a, b)

val result = graph.pregel(initialMsg)(vprog, sendMsg, mergeMsg)
```

## 7.12.7 Оптимизация и особенности масштабирования
- Графы разбиваются на партиции для параллельной обработки.  
- Используется модель `immutable` графа: каждое преобразование создаёт новый граф.  
- Агрегация сообщений минимизирует сетевой трафик между рабочими узлами.  
- Для больших графов рекомендуется использовать фильтрацию и агрегацию до выполнения сложных вычислений.  

## 7.12.8 Практические применения GraphX
- Анализ социальных сетей: поиск сообществ, лидеров мнений, распространения информации.  
- Обработка и анализ сетей дорог, маршрутизация.  
- Рекомендательные системы на основе графов связей.  
- Анализ биологических сетей (например, белковых взаимодействий).  
- Финансовый анализ: выявление мошеннических цепочек транзакций.  

## 7.12.9 Ограничения GraphX
- Отсутствие поддержки динамических графов (графы считаются статическими в ходе вычислений).  
- Ограниченное количество встроенных алгоритмов по сравнению с некоторыми специализированными графовыми СУБД.  
- Основная реализация — на Scala и Java, Python поддержка ограничена через PySpark.  